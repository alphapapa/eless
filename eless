#!/usr/bin/env bash
# Time-stamp: <2017-04-20 16:11:52 kmodi>
#
#* About
# Script to use emacs in the way 'less' is used.
# It basically opens the file (or stdin) in stock emacs in `view-mode'. Then
# you can do the following:
#
#* Switches to this script
#|------+-------------------------|
#| -gui | Run emacs in GUI mode   |
#| -D   | Run with debug messages |
#|------+-------------------------|
#
#* Common bindings in `view-mode':
#|------------+------------------------------------------------------------------------------|
#| SPC        | Scroll forward "page size" lines. With prefix scroll forward prefix lines.   |
#| DEL, S-SPC | Scroll backward "page size" lines. With prefix scroll backward prefix lines. |
#|            | (If your terminal does not support this, use xterm instead or using C-h.)    |
#| RET, LFD   | Scroll forward one line. With prefix scroll forward prefix line(s).          |
#| y          | Scroll backward one line. With prefix scroll backward prefix line(s).        |
#|------------+------------------------------------------------------------------------------|
#| s          | Do forward incremental search.                                               |
#| r          | Do reverse incremental search.                                               |
#|------------+------------------------------------------------------------------------------|
#| e          | Quit the `view-mode' and use that emacs session as usual to modify           |
#|            | the opened file if needed.                                                   |
#|------------+------------------------------------------------------------------------------|
#
#** Custom bindings
#|--------------+------------------------------|
#| q            | Quit emacs                   |
#| o            | Occur                        |
#| n            | Next line                    |
#| p            | Previous line                |
#| & or k       | Keep lines matching regexp   |
#| ! or K       | Delete lines matching regexp |
#| t            | Toggle line truncation       |
#| C-right/left | Inc/Dec frame width          |
#| C-down/up    | Inc/Dec frame height         |
#| = or + or -  | Adjust font size             |
#|--------------+------------------------------|
#
#* Usage Examples
#
#    eless foo.txt                  # This will work with -nw too
#    cat foo.txt | eless -          # This will not work with -nw; will force GUI mode
#    cat foo.txt | eless            # That hyphen is implicit. This will not work with -nw; will force GUI mode
#    cat foo.txt | grep bar | eless # Same as above
#
# Initialize variables
no_window_arg='-nw'             # Run emacs with -nw by default
debug=0
emacs_args=''
piped_data=''

input_from_pipe_flag=0
output_to_pipe_flag=0

for var in "$@"
do
    # echo "var : $var"
    if [[ "${var}" == '-D' ]]
    then
        debug=1
    fi
done

# Figure out if eless if getting input from a pipe or sending output to a pipe
# https://gist.github.com/davejamesmiller/1966557
if [[ -t 0 ]] # Script is called normally - Terminal input (keyboard) - interactive
then
    # eless foo
    # eless foo | cat -
    if [[ ${debug} -eq 1 ]]
    then
        echo "--> Input from terminal"
    fi
    input_from_pipe_flag=0
else # Script is getting input from pipe or file - non-interactive
    # echo bar | eless foo
    # echo bar | eless foo | cat -
    piped_data="$(cat)"
    if [[ ${debug} -eq 1 ]]
    then
        echo "--> Input from pipe/file"
    fi
    input_from_pipe_flag=1
fi

# http://stackoverflow.com/a/911213/1219634
if [[ -t 1 ]] # Output is going to the terminal
then
    # eless foo
    # echo bar | eless foo
    if [[ ${debug} -eq 1 ]]
    then
        echo "    Output to terminal -->"
    fi
    output_to_pipe_flag=0
else # Output is going to a pipe, file?
    # eless foo | cat -
    # echo bar | eless foo | cat -
    if [[ ${debug} -eq 1 ]]
    then
        echo "    Output to a pipe -->"
    fi
    output_to_pipe_flag=1
fi

emacs_args=()
for var in "$@"
do
    # echo "var : $var"
    if [[ "${var}" == '-D' ]]
    then
        debug=1
    elif [[ "${var}" == '-gui' ]]
    then
        no_window_arg=''
    elif [[ "${var}" == '-nw' ]]
    then
        do_nothing=1            # Ignore the -nw switch if passed by user
    else
        emacs_args=("${emacs_args[@]}" "${var}")
    fi
done

if [[ "${input_from_pipe_flag}" -eq 1 ]]
then
    # This is required because -nw does not work when emacs is receiving
    # input from a pipe.
    no_window_arg=''
fi

if [[ ! (${no_window_arg} == '') ]]
then
    emacs_args=("${no_window_arg}" "${emacs_args[@]}")
fi

if [[ ${debug} -eq 1 ]]
then
    echo "Raw Args      : $@"
    echo "No Window Arg : ${no_window_arg}"
    echo "Emacs Args    : ${emacs_args[@]}"
    echo "Pipe Contents : ${piped_data}"
fi

# Basic emacs function to provide 'less'-like capability
function emacs_Q_view_mode {

    if [[ ${debug} -eq 1 ]]
    then
        # Here $@ is the list of arguments passed specifically to emacs_Q_view_mode,
        # not to eless.
        echo "Args in emacs_Q_view_mode : $@"
    fi
    \emacs -Q "$@" \
           -f view-mode \
           --eval '(progn
                     ;; No clutter
                     (if (fboundp (quote tool-bar-mode)) (tool-bar-mode -1))
                     (if (fboundp (quote menu-bar-mode)) (menu-bar-mode -1))

                     ;; Pleasant dark theme
                     (load-theme (quote tango-dark) :no-confirm)

                     ;; Show line and column numbers in the mode-line
                     (line-number-mode 1)
                     (column-number-mode 1)

                     ;; Truncate long lines by default
                     (setq truncate-partial-width-windows nil) ; respect the value of truncate-lines
                     (toggle-truncate-lines +1)

                     ;; Highlight the current line
                     (hl-line-mode 1)

                     ;; My custom functions
                     (defun m/keep-lines ()
                       (interactive)
                       (let ((inhibit-read-only t))          ; ignore read-only status of buffer
                         (save-excursion
                           (goto-char (point-min))
                           (call-interactively (quote keep-lines)))))

                     (defun m/delete-matching-lines ()
                       (interactive)
                       (let ((inhibit-read-only t))          ; ignore read-only status of buffer
                         (save-excursion
                           (goto-char (point-min))
                           (call-interactively (quote delete-matching-lines)))))

                     (defun m/frame-width-half (double)
                       (interactive "P")
                       (let ((frame-resize-pixelwise t)   ;Do not round frame sizes to character h/w
                             (factor (if double 2 0.5)))
                         (set-frame-size nil (round (* factor (frame-text-width))) (frame-text-height) :pixelwise)))
                     (defun m/frame-width-double ()
                       (interactive)
                       (m/frame-width-half :double))

                     (defun m/frame-height-half (double)
                       (interactive "P")
                       (let ((frame-resize-pixelwise t)   ;Do not round frame sizes to character h/w
                             (factor (if double 2 0.5)))
                         (set-frame-size nil  (frame-text-width) (round (* factor (frame-text-height))) :pixelwise)))
                     (defun m/frame-height-double ()
                       (interactive)
                       (m/frame-height-half :double))

                     (fset (quote yes-or-no-p) (quote y-or-n-p)) ; Use y or n instead of yes or no

                     ;; My custom bindings
                     (define-key view-mode-map (kbd "q") (quote save-buffers-kill-emacs))
                     (define-key view-mode-map (kbd "n") (quote next-line))
                     (define-key view-mode-map (kbd "p") (quote previous-line))
                     (define-key view-mode-map (kbd "o") (quote occur))
                     (define-key view-mode-map (kbd "&") (quote m/keep-lines))
                     (define-key view-mode-map (kbd "k") (quote m/keep-lines))
                     (define-key view-mode-map (kbd "!") (quote m/delete-matching-lines))
                     (define-key view-mode-map (kbd "K") (quote m/delete-matching-lines))
                     (define-key view-mode-map (kbd "t") (quote toggle-truncate-lines))
                     (define-key view-mode-map (kbd "=") (quote text-scale-adjust))
                     (define-key view-mode-map (kbd "+") (quote text-scale-adjust))
                     (define-key view-mode-map (kbd "-") (quote text-scale-adjust))
                     (global-set-key (kbd "C-<right>") (quote m/frame-width-double))
                     (global-set-key (kbd "C-<left>") (quote m/frame-width-half))
                     (global-set-key (kbd "C-<down>") (quote m/frame-height-double))
                     (global-set-key (kbd "C-<up>") (quote m/frame-height-half))
                   )' \
                       > /dev/null 2>&1
}

# Below if condition is reached if you try to do this:
#   eless foo.txt | grep bar .. Not allowed.
if [[ ${output_to_pipe_flag} -eq 1 ]]
then
    echo "This script is not supposed to send output to a pipe"
    exit 1
else
    # Below if condition is reached when you do this:
    #   cat foo.txt | eless, or
    #   cat foo.txt | eless -
    # i.e. Input to eless is coming through a pipe (from cat, in above example)
    if [[ ${input_from_pipe_flag} -eq 1 ]]
    then
        tempfile="$(mktemp emacs-stdin-$USER.XXXXXXX --tmpdir)"
        echo "${piped_data}" > "$tempfile"
        if [[ ${debug} -eq 1 ]]
        then
            echo "temp file: $tempfile"
        fi
        cmd="emacs_Q_view_mode $tempfile \
                         ${emacs_args[@]} \
                         --eval '(progn
                                   (set-visited-file-name nil)
                                   (rename-buffer \"*stdin*\" :unique)
                                 )'"

        # Below else condition is reached when you do this:
        #   eless foo.txt
    else
        cmd="emacs_Q_view_mode ${emacs_args[@]}"
    fi
    if [[ ${debug} -eq 1 ]]
    then
        echo "Eless Command : $cmd"
    fi
    eval "$cmd"
fi

#* Other default bindings in `view-mode':
#|--------+-------------------------------------------------------------------------|
#| h or ? | Search for 'View minor mode' in that buffer to get this help.           |
#| Digits | Provide prefix arguments                                                |
#| <      | Move to the beginning of buffer.                                        |
#| >      | Move to the end of buffer.                                              |
#| z      | Like  SPC  but with prefix sets "page size" to prefix.                  |
#| w      | Like  DEL  but with prefix sets "page size" to prefix.                  |
#| d      | Scroll forward "half page size" lines.  With prefix, sets               |
#|        | "half page size" to prefix lines and scrolls forward that much.         |
#| u      | Scroll backward "half page size" lines.  With prefix, sets              |
#|        | "half page size" to prefix lines and scrolls backward that much.        |
#| F      | Revert-buffer if necessary and scroll forward.                          |
#|        | Use this to view a changing file.                                       |
#| =      | Prints the current line number.                                         |
#| %      | Goes prefix argument (default 100) percent into buffer.                 |
#| g      | Goes to line given by prefix argument (default first line).             |
#| .      | Set the mark.                                                           |
#| x      | Exchanges point and mark.                                               |
#| @      | Return to mark and pops mark ring.                                      |
#|        | Mark ring is pushed at start of every successful search and when        |
#|        | Jump to line occurs.  The mark is set on jump to buffer start or end.   |
#| m      | Save current position in character register.                            |
#| '      | Go to position saved in character register.                             |
#| /      | Searches forward for regular expression, starting after current page.   |
#|        | ! and @ have a special meaning at the beginning of the regexp.          |
#|        | ! means search for a line with no match for regexp.  @ means start      |
#|        | Search at beginning (end for backward search) of buffer.                |
#| \      | Searches backward for regular expression, starting before current page. |
#| E      | Exit View mode, and make the current buffer editable                    |
#|        | Even if it was not editable before entry to View mode.                  |
#| Q      | Quit View mode, restoring all windows to previous state.                |
#| c      | Quit View mode and maybe switch buffers, but don't kill this buffer.    |
#| C      | Quit View mode, kill current buffer and go back to other buffer.        |
#|--------+-------------------------------------------------------------------------|
#
#* References:
#  http://superuser.com/a/843744/209371
#  http://stackoverflow.com/a/15330784/1219634 - /dev/stdin (Kept just for
#    reference, not using this in this script any more.)
#  https://github.com/dj08/utils-generic/blob/master/eless
