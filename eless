#!/usr/bin/env bash
# Time-stamp: <2017-04-25 13:54:41 kmodi>
#
# This script uses the unofficial strict mode as explained in
# http://redsymbol.net/articles/unofficial-bash-strict-mode
#
# Also checks have been done with www.shellcheck.net to have a level of
# confidence that this script will be free of loopholes.. or is it? :)

h="
Script to run emacs in view-mode with some sane defaults in attempt to replace
less, diff, man, (probably ls too).

* Switches to this script
|------+-------------------------|
| -h   | Show this help          |
| -gui | Run emacs in GUI mode   |
| -D   | Run with debug messages |
|------+-------------------------|

* Common bindings in 'view-mode'
|--------------+------------------------------------------------------------------------------|
| SPC          | Scroll forward 'page size' lines. With prefix scroll forward prefix lines.   |
| DEL or S-SPC | Scroll backward 'page size' lines. With prefix scroll backward prefix lines. |
|              | (If your terminal does not support this, use xterm instead or using C-h.)    |
| RET          | Scroll forward one line. With prefix scroll forward prefix line(s).          |
| y            | Scroll backward one line. With prefix scroll backward prefix line(s).        |
|--------------+------------------------------------------------------------------------------|
| s            | Do forward incremental search.                                               |
| r            | Do reverse incremental search.                                               |
|--------------+------------------------------------------------------------------------------|
| e            | Quit the 'view-mode' and use that emacs session as usual to modify           |
|              | the opened file if needed.                                                   |
|--------------+------------------------------------------------------------------------------|

** Custom bindings
|--------------+--------------------------------------------------------|
| ! or K       | Delete lines matching regexp                           |
| & or k       | Keep lines matching regexp                             |
| = or + or -  | Adjust font size                                       |
| 0            | Delete this window                                     |
| 1            | Keep only this window                                  |
| A            | Auto-revert Tail Mode (like tail -f on current buffer) |
| N            | Next error (next line in *occur*)                      |
| P            | Previous error (previous line in *occur*)              |
| C-down/up    | Inc/Dec frame height                                   |
| C-right/left | Inc/Dec frame width                                    |
| g or F5      | Revert buffer (probably after keep/delete lines)       |
| n            | Next line                                              |
| o            | Occur                                                  |
| p            | Previous line                                          |
| q            | Quit emacs                                             |
| t            | Toggle line truncation                                 |
|--------------+--------------------------------------------------------|

** Do 'C-h b' and search for 'view-mode' to see more bindings in this mode.

* Usage Examples

    eless foo.txt                  # This will work with -nw too
    cat foo.txt | eless -          # This will not work with -nw; will force GUI mode
    cat foo.txt | eless            # That hyphen is implicit. This will not work with -nw; will force GUI mode
    cat foo.txt | grep bar | eless # Same as above
    PAGER=eless man grep           # If the environment variable PAGER is set to eless, launches man pages in eless (GUI mode)
    diff foo bar | eless           # Colored diff
    eless .                        # Open dired in the current directory (enhanced 'ls')
    eless -h | eless               # See eless help ;-)
"

set -o pipefail
set -e # Error out and exit the script when any line in this script returns an error
set -u # Error out when unbound variables are found

# IFS=$'\n\t' # Separate fields in a sequence only at newlines and tab characters
IFS=$' ' # Separate each field in a sequence at space characters

# Initialize variables
help=0
debug=0
no_window_arg="-nw"
emacs_args=("${no_window_arg}") # Run emacs with -nw by default
piped_data=''
tempfile=''
cmd=''

input_from_pipe_flag=0
output_to_pipe_flag=0

for var in "$@"
do
    # echo "var : $var"
    if [[ "${var}" == '-D' ]]
    then
        debug=1
    fi
done

# Figure out if eless if getting input from a pipe or sending output to a pipe
# https://gist.github.com/davejamesmiller/1966557
if [[ -t 0 ]] # Script is called normally - Terminal input (keyboard) - interactive
then
    # eless foo
    # eless foo | cat -
    if [[ ${debug} -eq 1 ]]
    then
        echo "--> Input from terminal"
    fi
    input_from_pipe_flag=0
else # Script is getting input from pipe or file - non-interactive
    # echo bar | eless foo
    # echo bar | eless foo | cat -
    piped_data="$(cat)"
    if [[ ${debug} -eq 1 ]]
    then
        echo "--> Input from pipe/file"
    fi
    input_from_pipe_flag=1
fi

# http://stackoverflow.com/a/911213/1219634
if [[ -t 1 ]] # Output is going to the terminal
then
    # eless foo
    # echo bar | eless foo
    if [[ ${debug} -eq 1 ]]
    then
        echo "    Output to terminal -->"
    fi
    output_to_pipe_flag=0
else # Output is going to a pipe, file?
    # eless foo | cat -
    # echo bar | eless foo | cat -
    if [[ ${debug} -eq 1 ]]
    then
        echo "    Output to a pipe -->"
    fi
    output_to_pipe_flag=1
fi

for var in "$@"
do
    if [[ ${debug} -eq 1 ]]
    then
        echo "var : $var"
    fi
    if [[ "${var}" == '-D' ]]
    then
        : # Do not pass -D option to emacs
    elif [[ "${var}" == '-h' ]]
    then
        help=1
    elif [[ "${var}" == '-gui' ]]
    then
        # Delete the ${no_window_arg} from ${emacs_args[@]} array
        # http://stackoverflow.com/a/16861932/1219634
        emacs_args=("${emacs_args[@]/${no_window_arg}}")
    elif [[ "${var}" == '-nw' ]]
    then
        : # Put just a colon to represent null operation # https://unix.stackexchange.com/a/133976/57923
    else
        emacs_args=("${emacs_args[@]}" "${var}")
    fi
done

if [[ ${help} -eq 1 ]]
then
    echo "${h}"
    exit 0
fi

if [[ "${input_from_pipe_flag}" -eq 1 ]]
then
    # Delete the ${no_window_arg} from ${emacs_args[@]} array
    # This is required because -nw does not work when emacs is receiving
    # input from a pipe.
    emacs_args=("${emacs_args[@]/${no_window_arg}}")
fi

if [[ ${debug} -eq 1 ]]
then
    echo "Raw Args      : $*" # https://github.com/koalaman/shellcheck/wiki/SC2145
    echo "Emacs Args    : ${emacs_args[*]}"
    echo "Pipe Contents : ${piped_data}"
fi

# Basic emacs function to provide 'less'-like capability
function emacs_Q_view_mode {

    if [[ ${debug} -eq 1 ]]
    then
        # Here $@ is the list of arguments passed specifically to emacs_Q_view_mode,
        # not to eless.
        echo "Args in emacs_Q_view_mode : $*"
    fi
    emacs -Q "$@" \
          -f view-mode \
          --eval '(progn
                     ;; Keep the default-directory to be the same from where
                     ;; this script was launched from; useful during C-x C-f
                     (setq default-directory "'"$(pwd)"'/")

                     ;; No clutter
                     (menu-bar-mode -1)
                     (if (fboundp (quote tool-bar-mode)) (tool-bar-mode -1))

                     ;; Pleasant dark theme
                     (load-theme (quote tango-dark) :no-confirm)

                     ;; Show line and column numbers in the mode-line
                     (line-number-mode 1)
                     (column-number-mode 1)

                     (ido-mode 1)
                     (setq ido-enable-flex-matching t)       ;Enable fuzzy search
                     (setq ido-everywhere t)
                     (setq ido-create-new-buffer (quote always)) ;Create a new buffer if no buffer matches substringv
                     (setq ido-use-filename-at-point (quote guess)) ;Find file at point using ido
                     (add-to-list (quote ido-ignore-buffers) "*Messages*")

                     (setq-default indent-tabs-mode nil) ;Use spaces instead of tabs for indentation
                     (setq x-select-enable-clipboard t)
                     (setq x-select-enable-primary t)
                     (setq save-interprogram-paste-before-kill t)
                     (setq require-final-newline t)
                     (setq visible-bell t)
                     (setq load-prefer-newer t)
                     (setq ediff-window-setup-function (quote ediff-setup-windows-plain))

                     (setq isearch-allow-scroll t) ;Allow scrolling using isearch
                     ;; DEL during isearch should edit the search string, not jump back to the previous result.
                     (define-key isearch-mode-map [remap isearch-delete-char] (quote isearch-del-char))

                     ;; Truncate long lines by default
                     (setq truncate-partial-width-windows nil) ;Respect the value of truncate-lines
                     (toggle-truncate-lines +1)

                     ;; Highlight the current line
                     (hl-line-mode 1)

                     ;; My custom functions
                     (defun eless/keep-lines ()
                       (interactive)
                       (let ((inhibit-read-only t)) ;Ignore read-only status of buffer
                         (save-excursion
                           (goto-char (point-min))
                           (call-interactively (quote keep-lines)))))

                     (defun eless/delete-matching-lines ()
                       (interactive)
                       (let ((inhibit-read-only t)) ;Ignore read-only status of buffer
                         (save-excursion
                           (goto-char (point-min))
                           (call-interactively (quote delete-matching-lines)))))

                     (defun eless/frame-width-half (double)
                       (interactive "P")
                       (let ((frame-resize-pixelwise t) ;Do not round frame sizes to character h/w
                             (factor (if double 2 0.5)))
                         (set-frame-size nil (round (* factor (frame-text-width))) (frame-text-height) :pixelwise)))
                     (defun eless/frame-width-double ()
                       (interactive)
                       (eless/frame-width-half :double))

                     (defun eless/frame-height-half (double)
                       (interactive "P")
                       (let ((frame-resize-pixelwise t) ;Do not round frame sizes to character h/w
                             (factor (if double 2 0.5)))
                         (set-frame-size nil  (frame-text-width) (round (* factor (frame-text-height))) :pixelwise)))
                     (defun eless/frame-height-double ()
                       (interactive)
                       (eless/frame-height-half :double))

                     (defun eless/revert-buffer-retain-view-mode ()
                       (interactive)
                       (let ((view-mode-state view-mode)) ;save the current state of view-mode
                         (revert-buffer)
                         (when view-mode-state
                           (view-mode 1))))

                     (defun eless/enable-diff-mode-maybe ()
                       (interactive)
                       (save-excursion
                         (goto-char (point-min))
                         (when (re-search-forward "^\\(?:[0-9]+,\\)?[0-9]+\\(?1:[adc]\\)\\(?:[0-9]+,\\)?[0-9]+$" nil :noerror)
                           (forward-line 1)
                           (let ((diff-type (match-string-no-properties 1))
                                 (diff-mode-enable nil))
                             (cond
                              ;; Line(s) added
                              ((string= diff-type "a")
                               (when (re-search-forward "^> " nil :noerror)
                                 (setq diff-mode-enable t)))
                              ;; Line(s) deleted or changed
                              (t
                               (when (re-search-forward "^< " nil :noerror)
                                 (setq diff-mode-enable t))))
                             (when diff-mode-enable
                               (diff-mode)
                               (rename-buffer "*Diff*" :unique)
                               (view-mode 1)))))) ;Re-enable view-mode

                     ;; Auto-enable diff-mode; diff foo bar | eless
                     (eless/enable-diff-mode-maybe)

                     (defun eless/dired-mode-customization ()
                       (view-mode -1) ;Prevent view-mode bindings from shadowing dired-mode bindings
                       (define-key dired-mode-map (kbd "q") (quote save-buffers-kill-emacs))
                       (define-key dired-mode-map (kbd "Q") (quote quit-window))
                       (define-key dired-mode-map (kbd "E") (quote wdired-change-to-wdired-mode)))
                     (add-hook (quote dired-mode-hook) (quote eless/dired-mode-customization))
                     ;; Apply above customization if the current major-mode is already dired-mode
                     (when (derived-mode-p (quote dired-mode))
                       (eless/dired-mode-customization))

                     (fset (quote yes-or-no-p) (quote y-or-n-p)) ;Use y or n instead of yes or no

                     ;; view-mode custom bindings
                     (define-key view-mode-map (kbd "!") (quote eless/delete-matching-lines))
                     (define-key view-mode-map (kbd "&") (quote eless/keep-lines))
                     (define-key view-mode-map (kbd "+") (quote text-scale-adjust))
                     (define-key view-mode-map (kbd "-") (quote text-scale-adjust))
                     (define-key view-mode-map (kbd "=") (quote text-scale-adjust))
                     (define-key view-mode-map (kbd "0") (quote delete-window))
                     (define-key view-mode-map (kbd "1") (quote delete-other-windows))
                     (define-key view-mode-map (kbd "A") (quote auto-revert-tail-mode))
                     (define-key view-mode-map (kbd "N") (quote next-error)) ;Next line in *occur*
                     (define-key view-mode-map (kbd "P") (quote previous-error)) ;Previous line in *occur*
                     (define-key view-mode-map (kbd "K") (quote eless/delete-matching-lines))
                     (define-key view-mode-map (kbd "g") (quote eless/revert-buffer-retain-view-mode))
                     (define-key view-mode-map (kbd "k") (quote eless/keep-lines))
                     (define-key view-mode-map (kbd "n") (quote next-line))
                     (define-key view-mode-map (kbd "o") (quote occur))
                     (define-key view-mode-map (kbd "p") (quote previous-line))
                     (define-key view-mode-map (kbd "q") (quote save-buffers-kill-emacs))
                     (define-key view-mode-map (kbd "t") (quote toggle-truncate-lines))

                     ;; global custom bindings
                     (global-set-key (kbd "M-/") (quote hippie-expand))
                     (global-set-key (kbd "C-x C-b") (quote ibuffer))
                     (global-set-key (kbd "C-c q") (quote query-replace-regexp))
                     (global-set-key (kbd "<f5>") (quote eless/revert-buffer-retain-view-mode))
                     (global-set-key (kbd "C-<right>") (quote eless/frame-width-double))
                     (global-set-key (kbd "C-<left>") (quote eless/frame-width-half))
                     (global-set-key (kbd "C-<down>") (quote eless/frame-height-double))
                     (global-set-key (kbd "C-<up>") (quote eless/frame-height-half))
                   )' \
                       2>/dev/null
}

# Below if condition is reached if you try to do this:
#   eless foo.txt | grep bar .. Not allowed.
if [[ ${output_to_pipe_flag} -eq 1 ]]
then
    echo "This script is not supposed to send output to a pipe"
    exit 1
else
    # Below if condition is reached when you do this:
    #   cat foo.txt | eless, or
    #   cat foo.txt | eless -
    # i.e. Input to eless is coming through a pipe (from cat, in above example)
    if [[ ${input_from_pipe_flag} -eq 1 ]]
    then
        tempfile="$(mktemp emacs-stdin-"$USER".XXXXXXX --tmpdir)" # https://github.com/koalaman/shellcheck/wiki/SC2086
        if [[ ${debug} -eq 1 ]]
        then
            echo "Temp File : $tempfile"
        fi
        echo "${piped_data}" > "${tempfile}" # https://github.com/koalaman/shellcheck/wiki/SC2086

        # Parse the first line of the piped data to check if it's a man page
        first_line_piped_data=$(head -n 1 "${tempfile}")
        if [[ ${debug} -eq 1 ]]
        then
            echo "first_line_piped_data = ${first_line_piped_data}"
        fi
        # The first line of man pages is assumed to be
        #   FOO(1)  something something something FOO(1)
        # It is not mandatory for the below grep to always pass, so OR it with
        # true so that "set -e" does not kill the script at this point.
        man_page=$(echo "${first_line_piped_data}" | grep -Po '^([A-Z]+\([0-9]+\))(?=\s+.*?\1$)' || true)

        if [[ -z ${man_page} ]] # No man page detected
        then
            if [[ ${debug} -eq 1 ]]
            then
                echo "No man page detected"
            fi
            cmd="emacs_Q_view_mode ${tempfile} \
                         ${emacs_args[*]} \
                         --eval '(progn
                                   (set-visited-file-name nil)
                                   (rename-buffer \"*Stdin*\" :unique)
                                 )'"
        else
            # This now allows setting the PAGER environment variable to eless.
            # After setting PAGER variable to eless, try something like
            # `man grep'.. That will launch the man page in eless in GUI mode.
            if [[ ${debug} -eq 1 ]]
            then
                echo "Man Page = ${man_page}"
            fi
            cmd="emacs_Q_view_mode \
                         ${emacs_args[*]} \
                         --eval '(progn
                                   (man (downcase \"${man_page}\"))
                                   (delete-window)
                                 )'"

        fi
        # Below else condition is reached when you do this:
        #   eless foo.txt
    else
        cmd="emacs_Q_view_mode ${emacs_args[*]}"
    fi
    if [[ ${debug} -eq 1 ]]
    then
        echo "Eless Command : $cmd"
    fi
    eval "$cmd"
    if [[ ! -z "${tempfile}" ]] && [[ ${debug} -eq 0 ]]
    then
        rm -f "${tempfile}"
    fi
fi

# References:
#  http://superuser.com/a/843744/209371
#  http://stackoverflow.com/a/15330784/1219634 - /dev/stdin (Kept just for
#    reference, not using this in this script any more.)
#  https://github.com/dj08/utils-generic/blob/master/eless
