#!/usr/bin/env bash
# Time-stamp: <2017-04-21 00:42:17 kmodi>
#
#* About
# Script to use emacs in the way 'less' is used.
# It basically opens the file (or stdin) in stock emacs in `view-mode'. Then
# you can do the following:
#
#* Switches to this script
#|------+-------------------------|
#| -gui | Run emacs in GUI mode   |
#| -D   | Run with debug messages |
#|------+-------------------------|
#
#* Common bindings in `view-mode':
#|------------+------------------------------------------------------------------------------|
#| SPC        | Scroll forward "page size" lines. With prefix scroll forward prefix lines.   |
#| DEL, S-SPC | Scroll backward "page size" lines. With prefix scroll backward prefix lines. |
#|            | (If your terminal does not support this, use xterm instead or using C-h.)    |
#| RET, LFD   | Scroll forward one line. With prefix scroll forward prefix line(s).          |
#| y          | Scroll backward one line. With prefix scroll backward prefix line(s).        |
#|------------+------------------------------------------------------------------------------|
#| s          | Do forward incremental search.                                               |
#| r          | Do reverse incremental search.                                               |
#|------------+------------------------------------------------------------------------------|
#| e          | Quit the `view-mode' and use that emacs session as usual to modify           |
#|            | the opened file if needed.                                                   |
#|------------+------------------------------------------------------------------------------|
#
#** Custom bindings
#|--------------+--------------------------------------------------|
#| q            | Quit emacs                                       |
#| o            | Occur                                            |
#| n            | Next line                                        |
#| p            | Previous line                                    |
#| & or k       | Keep lines matching regexp                       |
#| ! or K       | Delete lines matching regexp                     |
#| g or F5      | Revert buffer (probably after above keep/delete) |
#| t            | Toggle line truncation                           |
#| C-right/left | Inc/Dec frame width                              |
#| C-down/up    | Inc/Dec frame height                             |
#| = or + or -  | Adjust font size                                 |
#|--------------+--------------------------------------------------|
#
#* Usage Examples
#
#    eless foo.txt                  # This will work with -nw too
#    cat foo.txt | eless -          # This will not work with -nw; will force GUI mode
#    cat foo.txt | eless            # That hyphen is implicit. This will not work with -nw; will force GUI mode
#    cat foo.txt | grep bar | eless # Same as above
#    PAGER=eless man grep           # If the environemnt variable PAGER is set to eless, launches man pages in eless (GUI mode)
#    diff foo bar | eless           # Colored diff

# Initialize variables
no_window_arg='-nw'             # Run emacs with -nw by default
debug=0
emacs_args=''
piped_data=''
cmd=''

input_from_pipe_flag=0
output_to_pipe_flag=0

for var in "$@"
do
    # echo "var : $var"
    if [[ "${var}" == '-D' ]]
    then
        debug=1
    fi
done

# Figure out if eless if getting input from a pipe or sending output to a pipe
# https://gist.github.com/davejamesmiller/1966557
if [[ -t 0 ]] # Script is called normally - Terminal input (keyboard) - interactive
then
    # eless foo
    # eless foo | cat -
    if [[ ${debug} -eq 1 ]]
    then
        echo "--> Input from terminal"
    fi
    input_from_pipe_flag=0
else # Script is getting input from pipe or file - non-interactive
    # echo bar | eless foo
    # echo bar | eless foo | cat -
    piped_data="$(cat)"
    if [[ ${debug} -eq 1 ]]
    then
        echo "--> Input from pipe/file"
    fi
    input_from_pipe_flag=1
fi

# http://stackoverflow.com/a/911213/1219634
if [[ -t 1 ]] # Output is going to the terminal
then
    # eless foo
    # echo bar | eless foo
    if [[ ${debug} -eq 1 ]]
    then
        echo "    Output to terminal -->"
    fi
    output_to_pipe_flag=0
else # Output is going to a pipe, file?
    # eless foo | cat -
    # echo bar | eless foo | cat -
    if [[ ${debug} -eq 1 ]]
    then
        echo "    Output to a pipe -->"
    fi
    output_to_pipe_flag=1
fi

emacs_args=()
for var in "$@"
do
    # echo "var : $var"
    if [[ "${var}" == '-D' ]]
    then
        debug=1
    elif [[ "${var}" == '-gui' ]]
    then
        no_window_arg=''
    elif [[ "${var}" == '-nw' ]]
    then
        do_nothing=1            # Ignore the -nw switch if passed by user
    else
        emacs_args=("${emacs_args[@]}" "${var}")
    fi
done

if [[ "${input_from_pipe_flag}" -eq 1 ]]
then
    # This is required because -nw does not work when emacs is receiving
    # input from a pipe.
    no_window_arg=''
fi

if [[ ! (${no_window_arg} == '') ]]
then
    emacs_args=("${no_window_arg}" "${emacs_args[@]}")
fi

if [[ ${debug} -eq 1 ]]
then
    echo "Raw Args      : $@"
    echo "No Window Arg : ${no_window_arg}"
    echo "Emacs Args    : ${emacs_args[@]}"
    echo "Pipe Contents : ${piped_data}"
fi

# Basic emacs function to provide 'less'-like capability
function emacs_Q_view_mode {

    if [[ ${debug} -eq 1 ]]
    then
        # Here $@ is the list of arguments passed specifically to emacs_Q_view_mode,
        # not to eless.
        echo "Args in emacs_Q_view_mode : $@"
    fi
    \emacs -Q "$@" \
           -f view-mode \
           --eval '(progn
                     ;; Keep the default-directory to be the same from where
                     ;; this script was launched from; useful during C-x C-f
                     (setq default-directory "'"$(pwd)"'/")

                     ;; No clutter
                     (if (fboundp (quote tool-bar-mode)) (tool-bar-mode -1))
                     (if (fboundp (quote menu-bar-mode)) (menu-bar-mode -1))

                     ;; Pleasant dark theme
                     (load-theme (quote tango-dark) :no-confirm)

                     ;; Show line and column numbers in the mode-line
                     (line-number-mode 1)
                     (column-number-mode 1)

                     ;; Truncate long lines by default
                     (setq truncate-partial-width-windows nil) ;Respect the value of truncate-lines
                     (toggle-truncate-lines +1)

                     ;; Highlight the current line
                     (hl-line-mode 1)

                     ;; My custom functions
                     (defun m/keep-lines ()
                       (interactive)
                       (let ((inhibit-read-only t)) ;Ignore read-only status of buffer
                         (save-excursion
                           (goto-char (point-min))
                           (call-interactively (quote keep-lines)))))

                     (defun m/delete-matching-lines ()
                       (interactive)
                       (let ((inhibit-read-only t)) ;Ignore read-only status of buffer
                         (save-excursion
                           (goto-char (point-min))
                           (call-interactively (quote delete-matching-lines)))))

                     (defun m/frame-width-half (double)
                       (interactive "P")
                       (let ((frame-resize-pixelwise t) ;Do not round frame sizes to character h/w
                             (factor (if double 2 0.5)))
                         (set-frame-size nil (round (* factor (frame-text-width))) (frame-text-height) :pixelwise)))
                     (defun m/frame-width-double ()
                       (interactive)
                       (m/frame-width-half :double))

                     (defun m/frame-height-half (double)
                       (interactive "P")
                       (let ((frame-resize-pixelwise t) ;Do not round frame sizes to character h/w
                             (factor (if double 2 0.5)))
                         (set-frame-size nil  (frame-text-width) (round (* factor (frame-text-height))) :pixelwise)))
                     (defun m/frame-height-double ()
                       (interactive)
                       (m/frame-height-half :double))

                     (defun m/revert-buffer-retain-view-mode ()
                       (interactive)
                       (let ((view-mode-state view-mode)) ;save the current state of view-mode
                         (revert-buffer)
                         (when view-mode-state
                           (view-mode 1))))

                     (defun m/enable-diff-mode-maybe ()
                       (interactive)
                       (save-excursion
                         (goto-char (point-min))
                         (when (re-search-forward "^\\(?:[0-9]+,\\)?[0-9]+\\(?1:[adc]\\)\\(?:[0-9]+,\\)?[0-9]+$" nil :noerror)
                           (forward-line 1)
                           (let ((diff-type (match-string-no-properties 1))
                                 (diff-mode-enable nil))
                             (cond
                              ;; Line(s) added
                              ((string= diff-type "a")
                               (when (re-search-forward "^> " nil :noerror)
                                 (setq diff-mode-enable t)))
                              ;; Line(s) deleted or changed
                              (t
                               (when (re-search-forward "^< " nil :noerror)
                                 (setq diff-mode-enable t))))
                             (when diff-mode-enable
                               (diff-mode)
                               (rename-buffer "*Diff*" :unique)
                               (view-mode 1)))))) ;Re-enable view-mode

                     ;; Auto-enable diff-mode; diff foo bar | eless
                     (m/enable-diff-mode-maybe)

                     (fset (quote yes-or-no-p) (quote y-or-n-p)) ;Use y or n instead of yes or no

                     ;; My custom bindings
                     (define-key view-mode-map (kbd "q") (quote save-buffers-kill-emacs))
                     (define-key view-mode-map (kbd "n") (quote next-line))
                     (define-key view-mode-map (kbd "p") (quote previous-line))
                     (define-key view-mode-map (kbd "o") (quote occur))
                     (define-key view-mode-map (kbd "&") (quote m/keep-lines))
                     (define-key view-mode-map (kbd "k") (quote m/keep-lines))
                     (define-key view-mode-map (kbd "!") (quote m/delete-matching-lines))
                     (define-key view-mode-map (kbd "K") (quote m/delete-matching-lines))
                     (define-key view-mode-map (kbd "g") (quote m/revert-buffer-retain-view-mode))
                     (global-set-key (kbd "<f5>") (quote m/revert-buffer-retain-view-mode))
                     (define-key view-mode-map (kbd "t") (quote toggle-truncate-lines))
                     (define-key view-mode-map (kbd "=") (quote text-scale-adjust))
                     (define-key view-mode-map (kbd "+") (quote text-scale-adjust))
                     (define-key view-mode-map (kbd "-") (quote text-scale-adjust))
                     (global-set-key (kbd "C-<right>") (quote m/frame-width-double))
                     (global-set-key (kbd "C-<left>") (quote m/frame-width-half))
                     (global-set-key (kbd "C-<down>") (quote m/frame-height-double))
                     (global-set-key (kbd "C-<up>") (quote m/frame-height-half))
                   )' \
                       > /dev/null 2>&1
}

# Below if condition is reached if you try to do this:
#   eless foo.txt | grep bar .. Not allowed.
if [[ ${output_to_pipe_flag} -eq 1 ]]
then
    echo "This script is not supposed to send output to a pipe"
    exit 1
else
    # Below if condition is reached when you do this:
    #   cat foo.txt | eless, or
    #   cat foo.txt | eless -
    # i.e. Input to eless is coming through a pipe (from cat, in above example)
    if [[ ${input_from_pipe_flag} -eq 1 ]]
    then
        tempfile="$(mktemp emacs-stdin-$USER.XXXXXXX --tmpdir)"
        if [[ ${debug} -eq 1 ]]
        then
            echo "temp file: $tempfile"
        fi
        echo "${piped_data}" > ${tempfile}

        # Parse the first line of the piped data to check if it's a man page
        first_line_piped_data=$(head -n 1 ${tempfile})
        if [[ ${debug} -eq 1 ]]
        then
            echo "first_line_piped_data = ${first_line_piped_data}"
        fi
        # The first line of man pages is assumed to be
        #   FOO(1)  something something something FOO(1)
        man_page=$(echo "${first_line_piped_data}" | grep -Po '^([A-Z]+\([0-9]+\))(?=\s+.*?\1$)')

        if [[ -z ${man_page} ]] # No man page detected
        then
            if [[ ${debug} -eq 1 ]]
            then
                echo "No man page detected"
            fi
            cmd="emacs_Q_view_mode ${tempfile} \
                         ${emacs_args[@]} \
                         --eval '(progn
                                   (set-visited-file-name nil)
                                   (rename-buffer \"*Stdin*\" :unique)
                                 )'"
        else
            # This now allows setting the PAGER environment variable to eless.
            # After setting PAGER variable to eless, try something like
            # `man grep'.. That will launch the man page in eless in GUI mode.
            if [[ ${debug} -eq 1 ]]
            then
                echo "Man Page = ${man_page}"
            fi
            cmd="emacs_Q_view_mode \
                         ${emacs_args[@]} \
                         --eval '(progn
                                   (man (downcase \"${man_page}\"))
                                   (delete-window)
                                 )'"

        fi

        # Below else condition is reached when you do this:
        #   eless foo.txt
    else
        cmd="emacs_Q_view_mode ${emacs_args[@]}"
    fi
    if [[ ${debug} -eq 1 ]]
    then
        echo "Eless Command : $cmd"
    fi
    eval "$cmd"
fi

#* Other default bindings in `view-mode':
#|--------+-------------------------------------------------------------------------|
#| h or ? | Search for 'View minor mode' in that buffer to get this help.           |
#| Digits | Provide prefix arguments                                                |
#| <      | Move to the beginning of buffer.                                        |
#| >      | Move to the end of buffer.                                              |
#| z      | Like  SPC  but with prefix sets "page size" to prefix.                  |
#| w      | Like  DEL  but with prefix sets "page size" to prefix.                  |
#| d      | Scroll forward "half page size" lines.  With prefix, sets               |
#|        | "half page size" to prefix lines and scrolls forward that much.         |
#| u      | Scroll backward "half page size" lines.  With prefix, sets              |
#|        | "half page size" to prefix lines and scrolls backward that much.        |
#| F      | Revert-buffer if necessary and scroll forward.                          |
#|        | Use this to view a changing file.                                       |
#| =      | Prints the current line number.                                         |
#| %      | Goes prefix argument (default 100) percent into buffer.                 |
#| g      | Goes to line given by prefix argument (default first line).             |
#| .      | Set the mark.                                                           |
#| x      | Exchanges point and mark.                                               |
#| @      | Return to mark and pops mark ring.                                      |
#|        | Mark ring is pushed at start of every successful search and when        |
#|        | Jump to line occurs.  The mark is set on jump to buffer start or end.   |
#| m      | Save current position in character register.                            |
#| '      | Go to position saved in character register.                             |
#| /      | Searches forward for regular expression, starting after current page.   |
#|        | ! and @ have a special meaning at the beginning of the regexp.          |
#|        | ! means search for a line with no match for regexp.  @ means start      |
#|        | Search at beginning (end for backward search) of buffer.                |
#| \      | Searches backward for regular expression, starting before current page. |
#| E      | Exit View mode, and make the current buffer editable                    |
#|        | Even if it was not editable before entry to View mode.                  |
#| Q      | Quit View mode, restoring all windows to previous state.                |
#| c      | Quit View mode and maybe switch buffers, but don't kill this buffer.    |
#| C      | Quit View mode, kill current buffer and go back to other buffer.        |
#|--------+-------------------------------------------------------------------------|
#
#* References:
#  http://superuser.com/a/843744/209371
#  http://stackoverflow.com/a/15330784/1219634 - /dev/stdin (Kept just for
#    reference, not using this in this script any more.)
#  https://github.com/dj08/utils-generic/blob/master/eless
